'based on the work of Ken Perlin and Stefan Gustavson, 
'this is an attempt to port from Stefan's SimplexNoise.java to brightscript

function simplexnoise() as object
gradient3=[[1,1,0]
[-1,1,0]
[1,-1,0]
[-1,-1,0], [1,0,1]
[-1,0,1]
[1,0,-1]
[-1,0,-1],
[0,1,1]
[0,-1,1]
[0,1,-1]
[0,-1,-1]]
gradient4=[[0,1,1,1]
[0,1,1,-1]
[0,1,-1,1]
[0,1,-1,-1]
[0,-1,1,1]
[0,-1,1,-1]
[0,-1,-1,1]
[0,-1,-1,-1]
[1,0,1,1]
[1,0,1,-1]
[1,0,-1,1]
[1,0,-1,-1]
[-1,0,1,1]
[-1,0,1,-1]
[-1,0,-1,1]
[-1,0,-1,-1],
[1,1,0,1]
[1,1,0,-1]
[1,-1,0,1]
[1,-1,0,-1]
[-1,1,0,1]
[-1,1,0,-1]
[-1,-1,0,1]
[-1,-1,0,-1]
[1,1,1,0]
[1,1,-1,0]
[1,-1,1,0]
[1,-1,-1,0]
[-1,1,1,0]
[-1,1,-1,0]
[-1,-1,1,0]
[-1,-1,-1,0]]

permute1 = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]

'// To remove the need for index wrapping, double the permutation table length

permdouble=createobject("roarray",512,true)

for i=0 to 512
	permdouble[i]=permute1[i and 255]
end for

'// A lookup table to traverse the simplex around a given point in 4D. // Details can be found where this table is used, in the 4D noise method. 
simplexarray=[
		[0,1,2,3]
		[0,1,3,2]
		[0,0,0,0]
		[0,2,3,1]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[1,2,3,0]
		[0,2,1,3]
		[0,0,0,0]
		[0,3,1,2]
		[0,3,2,1]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[1,3,2,0]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[1,2,0,3]
		[0,0,0,0]
		[1,3,0,2]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[2,3,0,1]
		[2,3,1,0]
		[1,0,2,3]
		[1,0,3,2]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[2,0,3,1]
		[0,0,0,0]
		[2,1,3,0]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[2,0,1,3]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[3,0,1,2]
		[3,0,2,1]
		[0,0,0,0]
		[3,1,2,0]
		[2,1,0,3]
		[0,0,0,0]
		[0,0,0,0]
		[0,0,0,0]
		[3,1,0,2]
		[0,0,0,0]
		[3,2,0,1]
		[3,2,1,0]]

		
return {grad3:gradient3,grad4:gradient4,p:permute1,perm:permdouble,simplex:simplexarray,dot:dt3d,nze:noise,fastfloor:ff}
		
'This method is a *lot* faster than using (int)Math.floor(x)
'private static int fastfloor(double x) {} return x>0 ? (int)x : (int)x-1
end function

function ff(v as double) as integer 
if v >= 0 then
	return (V) 
else 
	return (V - 1)
end if
end function


function dt2d(g as object, x#, y#) as double 
return g[0]*x + g[1]*y

end function

function dt3d(g as object,x as double,y as double,z as double) as double 
	return g[0]*x + g[1]*y + g[2]*z 
end function

'4d private static double dot(int g[], double x, double y, double z, double w) { return g[0]*x + g[1]*y + g[2]*z + g[3]*w }
